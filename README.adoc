= Paneron host application

image:https://img.shields.io/badge/commitizen-friendly-brightgreen.svg[alt="Commitizen friendly",link="http://commitizen.github.io/cz-cli/"] image:https://github.com/paneron/paneron/workflows/Build/release/badge.svg[alt="Build/release"]

== Development

NOTE: At the moment, a migration from `yarn` to a `pnpm`-based monorepo
is in progress. This also involves splitting of the main `paneron` package
into three (`core,` `desktop` and `web`). Development process instructions
are not yet fully updated.

=== Testing

NOTE: Use manual testing.
Limited automated testing with `pnpm run -r test-mac-e2e` is under development.

==== Loading local extensions

Use Paneron settings window to specify directories with built extension packages.
Paneron will attempt to load versions in those directories
whenever corresponding extensions are requested.

This is useful if an extension is not published in the registry because it’s private,
or if published extension version is outdated (e.g., during testing).

==== Troubleshooting steps

This may be helpful if something is broken during testing.

Considering `%APP_DATA%` directory is under, e.g., `$HOME/Library/Application Support/Paneron` under macOS:

- Delete `%APP_DATA%/plugins`: This drops any plugins
- Delete `%APP_DATA%/index-dbs`: This drops LevelDB-backed dataset indexes
- Delete `%APP_DATA%/state`: This drops LevelDB-backed app UI state

=== Developing without a container

NOTE: Development environment has been tested on macOS Monterey and Ubuntu 18.

Global pre-requisites:

* macOS: Xcode and the accompanying command-line tools
* Node 16 (installation:
  link:https://github.com/nodesource/distributions/blob/master/README.md#installation-instructions[Ubuntu],
  link:https://nodejs.org/en/download/package-manager/#macos[macOS])
* pnpm (link:https://pnpm.io/installation[installation^])
* Ubuntu: `libsecret-1-dev` (may or may not be installed by default)
  and some frontend such as `gnome-keyring`.
  (See also `Dockerfile` for how those are installed in a headless setup.)

From project root run `pnpm install`.

- Development mode: run `pnpm run dev`.
- Compilation: run `pnpm run compile`.
- Building the app: run `pnpm run dist`.

(For less tested development flows that use containers
for invoking LSP and/or the dev command, see below.)

=== Developing in a container

NOTE: At the moment, a migration from `yarn` to a `pnpm`-based monorepo is in progress.
Containerized development flow is not fully updated for PNPM.

This allows you to run type checking and even development server
in an isolated environment without having global pre-requisites installed
on your working machine.

Global pre-requisites: only Docker (tested with Docker Desktop).

==== Containerized LSP

The provided `tsserver.Dockerfile` has all the dependencies and launches
TypeScript language server in stdio mode as default command.
Use your IDE’s host to communicate. Tested with Neovim 0.7.

==== Containerized `pnpm run dev`

NOTE: This is not a well-tested flow. Works under macOS Monterey with glitches.

Ensure your host machine has an X11 server running and accepting connections
from network clients (on macOS, there is an option XQuartz preferences
and you may additionally need to execute `xhost +localhost`).

Use the provided Dockerfile to build and run the image:

[source]
----
docker build -t paneron-dev .
docker run \
  -e DISPLAY=host.docker.internal:0 \
  --build-arg "project_path=/paneron" \
  -v "$(pwd)/runtime-config:/paneron/.config" \
  --privileged \
  paneron-dev
----

The `-v` flag makes it so that the $HOME/.config directory,
containing among other things Paneron & Electron runtime data on Ubuntu,
is mounted within your project’s working directory for easier debugging.

=== Working on bundled libraries

When working on RegistryKit or ExtensionKit, you may want to run the app
with their local versions rather than those installed from NPM.

The convention for now is to 1) copy or symlink their compiled versions
into a special directory under project root:

[source]
----
mkdir -p dependencies-local
# either
cp -R /path/to/your/registry-kit/dist dependencies-local/registry-kit-dist
# or
ln -sf /path/to/your/registry-kit/dist dependencies-local/registry-kit-dist
----

then 2) replace their package.json entries with relative paths in the above
directory (*don’t commit* this change):

[source,diff]
----
-   "@riboseinc/paneron-registry-kit": "^1.2.3",
+   "@riboseinc/paneron-registry-kit": "file:./dependencies-local/registry-kit-dist",
----

...then, after you’re done making changes to RegistryKit and corresponding
changes to Paneron core,
3) release the new version of the library (e.g., RegistryKit)
and update the package.json record to use that version (instead of the
local path) *before* you commit your changes to Paneron:

[source,diff]
----
-   "@riboseinc/paneron-registry-kit": "file:./dependencies-local/registry-kit-dist",
+   "@riboseinc/paneron-registry-kit": "^1.2.4",
----

=== How we work

Here are conventions regarding working with Git, commit messages and release flow.

==== Release process

The roles and responsibilities are:

- QA: ensures what is released works from users’ perspective
  (this person could be also a developer, if there is no dedicated QA,
  but it’s not recommended)
- Developer: focuses on the codebase

When starting the work on the next version, QA:

. Creates a release draft on GitHub
  (tag name should be in the form of “v1.2.3”; release title can be anything).
. Updates version in package.json
  (package version should be in the form of “1.2.3”).

When working on the version:

* Optional: developer starts a feature (or fix) branch
  from an appropriate source/“upstream” branch.
  Generally it’d be the main branch,
  but it could be a major supported version branch[0]
** Creating a branch is not required for trivial changes such as README updates
   or changes that are otherwise agreed on
** If a branch is used, branch creator is expected to regularly rebase it
   to bring in new commits from source branch without a merge commit
* Developer pushes commits to the chosen branch
* When done, developer requests feature branch to be merged (using Github PR)
* Another developer reviews proposed changes to the code
* QA tests and reviews proposed changes to application behavior
* When considered suitable, QA merges feature branch into its source branch
  (e.g., main) by rebasing (without squashing) feature branch commits
  onto the main* branch

On each new commit in the main[0] branch,
CI attaches build artifacts to the release tag that exactly matches
the version in package.json—but only if that release is marked “draft”
on Github.

To release a version after the final commit is added
to the main< branch, QA:

. Waits until CI run completes and make sure the artifacts
  for each supported platform are attached to the draft release.
+
If something’s off, check build logs for each platform
and search for “publishing” in the “Build/release” step.
(For example, if the version in package.json during push did not match
the version of the draft release,
CI will silently skip attaching updated build artifacts to the draft
and binaries attached to the draft will be outdated.)
. Performs the ultimate QA checks against the artifacts attached to the draft.
  (Make sure that the artifacts attached are of correct versions,
  there are no regressions, and features work as intended.)
. If QA/tests succeeded, changes release status from draft to published.
. Starts the next version.

[0] This process does not fully cover a situation where
a new major version
comes out, but the previous version is still supported.
In that scenario the process may include major version branches as well.
This may require updating GHA workflows.

==== Commit guidelines

* Aim to achieve both of these goals:

** Each commit should be as focused on a particular change as possible.

*** E.g., don’t mix some some feature with a fix, or stylistic changes,
    or another feature. For stylistic cleanups, prefer to batch them
    into a separate commit.

** Each commit should contain the codebase in a complete, buildable state.

*** Try not to commit a change that relies on another change
    that you haven’t committed yet.

*** Compile, lint and test before committing.
+
There is a pre-push Git hook that compiles the app.
This helps us catch compilation errors before code reaches CI.
+
If for any reason you want to skip hooks, `git push --no-verify` can be used.

*** If you believe it’s useful to push incomplete work,
    you can go ahead if you’re working in a feature branch,
    but explicitly coordinate this if you are pushing into an upstream branch.


* This repository is set up with AngularJS commit message convention
  (or “conventional commit”), please read those.
  Detailed descriptions are appreciated.
+
The `prepare-commit-msg` hook will invoke interactive prompt, powered by Commitizen,
that will ask you for information and put together a commit message for you.
+
There is currently also a `commit-msg` Git hook that validates commit messages
with `commitlint`.

=== Managing the repository

==== Adding a global external dependency (`$a`)

This is for dependencies that are more convenient to have at the repo-level
rather than at the package-level.

. At the top-level directory, run:
+
[source,console]
----
paneron> pnpm i -w $a  # Add -D for devDependencies
----
. Commit the resulting changes including top-level `package.json` and
`pnpm-lock.yaml`.

==== Adding a package-level external dependency (`$a`)

This is for dependencies that apply more at the package-level than at the
repo-level.

. At the package-level directory, run:
+
[source,console]
----
paneron/packages/my_package> pnpm i $a  # Add -D for devDependencies
----
. Commit the resulting changes including package-level `package.json` and
`pnpm-lock.yaml`.

==== Adding a sub-package (`$A`)

. Create a PNPM project under the `packages/` directory. Let's call it `$A`.
. Edit the sub-package's `package.json`, such that:
** its `name` is prefixed with `@paneron/`, i.e. `@paneron/$A`;
** its `scripts` section has the following tasks as appropriate:
*** `clean`
*** `compile`
*** `dev`
*** `dist`
*** `lint:fix`
*** `lint`
** its `dependencies` section has references to other sub-packages (e.g. `$Z`) in the form of `"@paneron/$Z" : "workspace:*"` as appropriate.
. Edit the top-level `package.json`, such that its `dependencies` has an entry
  for `"@paneron/$A" : "workspace:*"`.

==== Renaming a sub-package (`$A` to `$B`)

. Rename the directory `packages/$A` to a new name, let's say `packages/$B`.
. Edit the sub-package's `package.json`, such that:
** its `name` contains the new name instead, i.e. `@paneron/$B`;
. Edit the top-level `package.json`, such that its `dependencies` has renamed
  the entry for `"@paneron/$A"` to `"@paneron/$B"`.

==== Removing a sub-package (`$A`)

. Remove the directory `packages/$A`.
. Edit `dependencies` in the top-level `package.json` to remove
  the entry for `"@paneron/$A"`.
