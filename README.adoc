= Paneron host application

:toc:
:toc-placement!:

image:https://img.shields.io/badge/commitizen-friendly-brightgreen.svg[alt="Commitizen friendly",link="http://commitizen.github.io/cz-cli/"] image:https://github.com/paneron/paneron/workflows/Build/release/badge.svg[alt="Build/release"]

toc::[]

== Development

=== Testing

NOTE: Use manual testing.
Limited automated testing with `pnpm run -r test-mac-e2e` is under development.

==== Loading local extensions

Use Paneron settings window to specify directories with built extension packages.
Paneron will attempt to load versions in those directories
whenever corresponding extensions are requested.

This is useful if an extension is not published in the registry because it’s private,
or if published extension version is outdated (e.g., during testing).

==== Troubleshooting steps

This may be helpful if something is broken during testing.

Considering `%APP_DATA%` directory is under, e.g., `$HOME/Library/Application Support/Paneron` under macOS:

- Delete `%APP_DATA%/plugins`: This drops any plugins
- Delete `%APP_DATA%/index-dbs`: This drops LevelDB-backed dataset indexes
- Delete `%APP_DATA%/state`: This drops LevelDB-backed app UI state

=== Developing without a container

NOTE: Development environment has been tested on macOS Monterey and Ubuntu 18.

Global pre-requisites:

* macOS: Xcode and the accompanying command-line tools
* Node 16 (installation:
  link:https://github.com/nodesource/distributions/blob/master/README.md#installation-instructions[Ubuntu],
  link:https://nodejs.org/en/download/package-manager/#macos[macOS])
* pnpm (link:https://pnpm.io/installation[installation^])
* Ubuntu: `libsecret-1-dev` (may or may not be installed by default)
  and some frontend such as `gnome-keyring`.
  (See also `Dockerfile` for how those are installed in a headless setup.)

From project root run `pnpm install`.

- Development mode: run `pnpm run dev`.
- Compilation: run `pnpm run compile`.
- Building an app: run `pnpm run dist`.

(For less tested development flows that use containers
for invoking LSP and/or the dev command, see below.)

=== Developing in a container

NOTE: At the moment, a migration from `yarn` to a `pnpm`-based monorepo is in progress.
Containerized development flow is not fully updated for PNPM.

This allows you to run type checking and even development server
in an isolated environment without having global pre-requisites installed
on your working machine.

Global pre-requisites: only Docker (tested with Docker Desktop).

==== Containerized LSP

The provided `tsserver.Dockerfile` has all the dependencies and launches
TypeScript language server in stdio mode as default command.
Use your IDE’s host to communicate. Tested with Neovim 0.7.

==== Containerized `pnpm run dev`

NOTE: This is not a well-tested flow. Works under macOS Monterey with glitches.

Ensure your host machine has an X11 server running and accepting connections
from network clients (on macOS, there is an option XQartz preferences
and you may additionally need to execute `xhost +localhost`).

Use the provided Dockerfile to build and run the image:

[source]
----
docker build -t paneron-dev .
docker run \
  -e DISPLAY=host.docker.internal:0 \
  --build-arg "project_path=/paneron" \
  -v "$(pwd)/runtime-config:/paneron/.config" \
  --privileged \
  paneron-dev
----

The `-v` flag makes it so that the $HOME/.config directory,
containing among other things Paneron & Electron runtime data on Ubuntu,
is mounted within your project’s working directory for easier debugging.

=== Working on bundled libraries

When working on RegistryKit or ExtensionKit, you may want to run the app
with their local versions rather than those installed from NPM.

The convention for now is to 1) copy or symlink their compiled versions
into a special directory under project root:

[source]
----
mkdir -p dependencies-local
# either
cp -R /path/to/your/registry-kit/dist dependencies-local/registry-kit-dist
# or
ln -sf /path/to/your/registry-kit/dist dependencies-local/registry-kit-dist
----

then 2) replace their package.json entries with relative paths in the above
directory (*don’t commit* this change):

[source]
----
-   "@riboseinc/paneron-registry-kit": "^1.2.3",
+   "@riboseinc/paneron-registry-kit": "file:./dependencies-local/registry-kit-dist",
----

...then, after you’re done making changes to RegistryKit and corresponding
changes to Paneron core,
3) release the new version of the library (e.g., RegistryKit)
and update the package.json record to use that version (instead of the
local path) *before* you commit your changes to Paneron:

[source]
----
-   "@riboseinc/paneron-registry-kit": "file:./dependencies-local/registry-kit-dist",
+   "@riboseinc/paneron-registry-kit": "^1.2.4",
----

=== Making changes

Here are conventions regarding working with Git, commit messages and release flow.

==== Committing

- Aim to achieve both of these goals:

  - Each commit should be as focused on a particular change as possible.
    (E.g., don’t mix some feature with a fix or stylistic changes
    or another feature.)

  - Each commit should contain the codebase in a complete, buildable state.
    (Don’t commit a change that relies on another change
    that you haven’t committed yet.)

- This repository is set up with AngularJS commit message convention
  (or “conventional commit”), please read those.
+
++++
<del>
Pre-commit hook will invoke interactive prompt, powered by Commitizen,
that will ask you for information and put together a commit message for you.
</del>
++++
There is currently no hook that would validate commit messages.

==== Pulling

- Use “rebase” behavior of pull by having this in your global .gitconfig:
+
[source]
----
[pull]
    rebase = true
----

==== Pushing

Make sure to compile, lint, test before you push.

++++
<del>There is a pre-push Git hook that compiles the app.
This helps us catch compilation errors before code reaches CI.</del>
++++
There’s no pre-push hook that does it for you at the time.

==== Releasing

CI builds the application automatically,
and attaches build artifacts to release tag that matches the version in package.json
if that release is still a draft.

===== Release sequence

When starting the work on a new version:

. Create a release draft on GitHub (tag name should be in the form of “v1.2.3” and release title can be anything).
. Update version in package.json (package version should be in the form of “1.2.3”).
. Push your commits as usual.

After your final push, when you think this version is ready:

. Wait until CI run completes, and artifacts for each platform are attached to release draft.
+
You may check build logs for each platform, looking for “publishing” in Build/release step,
to make sure all artifacts were indeed uploaded at the end.
+
If, for example, version in package.json during push did not match the draft release you want to publish,
then CI will silently skip attaching updated build artifacts to the draft, and binaries attached to the draft will be outdated.
. Perform QA/tests against artifacts attached to the draft. (Make sure that the artifacts attached are of correct versions, there are no regressions, and features work as intended.)
. If QA/tests succeeded, change release status from draft to published.
. Repeat from the top.
